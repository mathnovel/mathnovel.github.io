---
title: "qt程序捕捉崩溃的方法"
date: 2025-11-27 12:00:00  # 改为当前或过去时间！
categories:
  - c++
  - qt
tags:
  - c++
  - qt
layout: single
author_profile: true
excerpt: "qt程序捕捉崩溃"  # 修正拼写
header:
  overlay_image: /assets/images/post-header.jpg
  overlay_filter: 0.5
  caption: "IEO：[IEO](https://ieeoo.com)"
---

在 Windows 下使用 Qt 6 的 Debug 版本生成 Core Dump（Windows 中称为 “崩溃转储文件”，Dump File），需要结合 Windows 系统机制和 Qt 的编译配置来实现。以下是 3 种可靠方案，从简单到灵活逐步介绍，确保崩溃时自动生成 Dump 文件，方便后续用 Visual Studio 或 WinDbg 调试。

# 核心前提

1. 你的 Qt 程序必须是 Debug 版本（CMAKE_BUILD_TYPE=Debug 或 qmake 的 CONFIG+=debug），且编译时保留了符号信息（默认 Debug 版本会保留，不要加 -s 或 strip 等剥离符号的选项）。
2. 目标 Windows 系统需开启 “转储文件生成”（部分系统默认关闭，需手动配置）。

## 方案 1：通过 Windows 系统设置，全局生成 Dump（最简单，无需改代码）
Windows 自带 “崩溃转储生成” 功能，可全局配置所有程序崩溃时自动生成 Dump 文件，无需修改 Qt 代码，适合快速验证。

操作步骤
1. 打开 “注册表编辑器”：按 Win+R，输入 regedit 回车。

2. 定位到以下路径（32 位程序和 64 位程序路径不同，根据你的 Qt 编译架构选择）：
64 位程序（Qt 编译为 x64）：
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps
32 位程序（Qt 编译为 x86，运行在 64 位系统）：
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\Windows Error Reporting\LocalDumps
若没有 LocalDumps 文件夹，右键 Windows Error Reporting → 新建 → 项，命名为 LocalDumps。
3. 在 LocalDumps 下新建以下 DWORD 值 和 字符串值，配置 Dump 生成规则：

<img src="./img/1.png" />

4. 配置完成后，无需重启系统，直接运行你的 Qt Debug 程序。当程序崩溃时，Windows 会自动在 DumpFolder 路径下生成以 “程序名 + 进程 ID.dmp” 命名的文件（例如 MyQtApp_1234.dmp）。


## 方案 2：Qt 代码中集成 MiniDumpWriteDump（灵活控制，推荐）


通过 Windows API MiniDumpWriteDump 手动捕获崩溃信号，生成 Dump 文件。可自定义 Dump 保存路径、文件名，甚至在崩溃前执行清理逻辑，适合需要精细化控制的场景。
实现步骤
在 Qt 项目中添加以下代码（建议放在 main.cpp 或全局工具类中）：

```c++
#include <windows.h>
#include <DbgHelp.h>
#include <QCoreApplication>
#include <QDir>
#include <QDateTime>

// 链接 DbgHelp 库（生成 Dump 必需）
#pragma comment(lib, "DbgHelp.lib")

// 崩溃回调函数：捕获崩溃信号并生成 Dump
LONG WINAPI CrashHandler(EXCEPTION_POINTERS* pExceptionPointers)
{
    // 1. 定义 Dump 文件路径（例如：程序运行目录/Crashes/时间戳.dmp）
    QDir crashDir(QCoreApplication::applicationDirPath() + "/Crashes");
    if (!crashDir.exists()) {
        crashDir.mkpath("."); // 创建文件夹
    }
    QString dumpFileName = crashDir.filePath(
        QString("Crash_%1.dmp")
        .arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss"))
    );

    // 2. 创建 Dump 文件
    HANDLE hDumpFile = CreateFileA(
        dumpFileName.toLocal8Bit().constData(),
        GENERIC_WRITE,
        0,
        nullptr,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (hDumpFile != INVALID_HANDLE_VALUE) {
        MINIDUMP_EXCEPTION_INFORMATION dumpInfo;
        dumpInfo.ExceptionPointers = pExceptionPointers;
        dumpInfo.ThreadId = GetCurrentThreadId();
        dumpInfo.ClientPointers = TRUE;

        // 生成完整 Dump（MiniDumpWithFullMemory 表示完整转储，文件较大但调试信息全）
        MiniDumpWriteDump(
            GetCurrentProcess(),
            GetCurrentProcessId(),
            hDumpFile,
            MiniDumpWithFullMemory | MiniDumpWithHandleData, //  Dump 类型选项
            &dumpInfo,
            nullptr,
            nullptr
        );

        CloseHandle(hDumpFile); // 关闭文件句柄
    }

    // 3. 可选：崩溃后弹出提示（Qt 需在主线程，这里用 Windows API 简单提示）
    MessageBoxA(nullptr, "程序崩溃，已生成 Dump 文件！", "崩溃提示", MB_ICONERROR);

    // 返回异常处理结果（让系统继续默认处理，或退出程序）
    return EXCEPTION_EXECUTE_HANDLER;
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    // 注册崩溃回调：程序启动时生效
    SetUnhandledExceptionFilter(CrashHandler);

    // 你的程序逻辑...
    MainWindow w;
    w.show();

    return a.exec();
}
````

2. 配置 Qt 项目文件（.pro 或 CMakeLists.txt）：
qmake 项目（.pro 文件）：添加链接库和 Windows 编译选项：

````
QT += core gui widgets
TARGET = MyQtApp
TEMPLATE = app

# 仅 Debug 版本启用 Dump 生成（可选，避免 Release 版本冗余）
CONFIG(debug, debug|release) {
    LIBS += -lDbgHelp  # 链接 DbgHelp 库
    DEFINES += ENABLE_CRASH_DUMP
}

# Windows 编译选项（确保捕获所有崩溃类型）
QMAKE_CXXFLAGS += /EHa  # 启用异步异常处理（捕获访问冲突、空指针等）

````


CMake 项目（CMakeLists.txt）：

````
cmake_minimum_required(VERSION 3.5)
project(MyQtApp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_BUILD_TYPE Debug) # 确保是 Debug 版本

find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets)
qt_standard_project_setup()

add_executable(MyQtApp main.cpp MainWindow.cpp)
target_link_libraries(MyQtApp PRIVATE Qt6::Core Qt6::Gui Qt6::Widgets)

# 链接 DbgHelp 库（Windows 必需）
if (WIN32 AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_link_libraries(MyQtApp PRIVATE DbgHelp)
    target_compile_definitions(MyQtApp PRIVATE ENABLE_CRASH_DUMP)
    target_compile_options(MyQtApp PRIVATE /EHa) # 启用异步异常处理
endif()

````

3. 编译运行：程序崩溃时，会在 程序运行目录/Crashes 下生成 Dump 文件，同时弹出崩溃提示。

## 方案 3：使用 Qt 自带的 qInstallMessageHandler（捕获 Qt 特定崩溃）
Qt 提供 qInstallMessageHandler 可捕获 Qt 框架抛出的致命错误（如 Qt 断言失败、信号槽错误等），但无法捕获系统级崩溃（如空指针访问、内存越界）。建议与 方案 2 结合使用，确保覆盖所有崩溃场景。
示例代码（补充到方案 2 中）


````c++
// Qt 致命错误回调（捕获 Qt 框架级崩溃）
void QtFatalErrorHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    // 输出错误信息到日志（可选）
    QString errorMsg = QString("[Qt Fatal Error] %1 (File: %2, Line: %3)")
        .arg(msg)
        .arg(context.file)
        .arg(context.line);
    qDebug() << errorMsg;

    // 强制触发系统崩溃回调，生成 Dump 文件
    raise(SIGABRT); // 发送中止信号，触发 CrashHandler
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    // 注册系统崩溃回调（方案2）
    SetUnhandledExceptionFilter(CrashHandler);

    // 注册 Qt 致命错误回调（补充方案）
    qInstallMessageHandler(QtFatalErrorHandler);

    // 你的程序逻辑...
    MainWindow w;
    w.show();

    return a.exec();
}

````


## 如何调试 Dump 文件？

生成 .dmp 文件后，需用调试工具加载，结合 Debug 版本的程序和符号文件（.pdb）定位崩溃点：
工具选择
###  Visual Studio（推荐，简单直观）：
打开 Visual Studio → 菜单栏 → 文件 → 打开 → 文件 → 选择生成的 .dmp 文件。
弹出 “调试转储” 窗口，点击 “设置符号路径”：添加你的 Qt 程序 Debug 版本的输出目录（包含 .exe 和 .pdb 文件）。
点击 “开始调试”（绿色箭头），Visual Studio 会自动定位到崩溃的代码行、函数调用栈、变量值等信息。

打开 Visual Studio → 菜单栏 → 文件 → 打开 → 文件 → 选择生成的 .dmp 文件后，点击右上角的绿色三角形（不用添加符号路径）

<img src="/assets/img/9.png" />
<img src="/assets/img/.png" />

**visual studio 会自动加载exe和pdb，如果程序被重新编译过，有改动，就无法用dmp文件调试了,会提示找不到pdb文件**

###  WinDbg（微软官方工具，适合复杂场景）：
下载 WinDbg（Windows 10/11 可通过 Microsoft Store 安装）。
打开 WinDbg → 文件 → 打开崩溃转储 → 选择 .dmp 文件。
配置符号路径：输入命令 !symfix C:\Symbols（自动下载系统符号），再输入 !sympath+ 你的程序输出目录（加载自定义符号）。
输入命令 k 查看调用栈，!analyze -v 自动分析崩溃原因。


## 关键注意事项
保留 PDB 文件：Debug 版本编译时会生成 .pdb 符号文件（与 .exe 同目录），调试 Dump 必须依赖此文件，切勿删除或修改。
Dump 类型选择：MiniDumpWithFullMemory 生成完整转储（文件较大，几 GB 可能），但包含所有内存信息，调试最准确；MiniDumpNormal 生成迷你转储（几十 MB），仅包含核心信息，适合快速排查。
Qt 编译架构匹配：程序是 x86 还是 x64，需与系统注册表配置、调试工具架构一致（例如 x64 程序用 x64 版本的 Visual Studio/WinDbg）。
避免 Release 版本：Release 版本会优化代码（变量消除、函数内联），即使生成 Dump，调试时也难以定位到原始代码行，务必用 Debug 版本。
通过以上方案，你的 Qt 6 Debug 程序崩溃时会自动生成 Dump 文件，结合调试工具可高效定位崩溃原因（如空指针、数组越界、线程同步问题等）。优先推荐 方案 2（代码集成）+ 方案 3（Qt 错误捕获），兼顾灵活性和全面性。


## 方案2，3的结合


以下是 方案 2（系统级崩溃捕获）+ 方案 3（Qt 框架崩溃捕获） 的完整集成实现，包含 main.cpp 完整代码、.pro 项目配置（qmake）和 CMakeLists.txt 配置（CMake），可直接复制使用，确保覆盖 系统级崩溃（空指针、内存越界等）和 Qt 框架级崩溃（断言失败、信号槽错误等）。
一、完整代码实现（main.cpp）

````c++
#include <windows.h>
#include <DbgHelp.h>
#include <signal.h>
#include <QApplication>
#include <QDir>
#include <QDateTime>
#include <QMessageLogContext>
#include <QDebug>
//=---------------------------------------------------
#include <DbgHelp.h>
#include <signal.h>
#include <QApplication>
#include <QDir>
#include <QDateTime>
#include <QMessageLogContext>
#include <QDebug>


// 链接 DbgHelp 库（生成Dump必需）
#pragma comment(lib, "DbgHelp.lib")
// ==================== 全局配置（可根据需求修改）====================
// Dump文件保存根目录（相对程序运行目录）
const QString DUMP_SAVE_DIR = "QtCrashDumps";
// 最大保留Dump文件数量（避免占用过多空间）
const int MAX_DUMP_COUNT = 10;
// Dump文件类型：MiniDumpWithFullMemory（完整转储，调试信息全）
// 修复后代码（添加显式强制转换）
const MINIDUMP_TYPE DUMP_TYPE = static_cast<MINIDUMP_TYPE>(
    MiniDumpWithFullMemory |
    MiniDumpWithHandleData |
    MiniDumpWithThreadInfo
    );
// ==================== 辅助工具函数：Windows 信号描述映射（替换 strsignal）====================
// 获取信号对应的中文描述（Windows 兼容）
QString getSignalDescription(int signal)
{
    switch (signal) {
    case SIGABRT:  return "SIGABRT（程序中止信号，通常由 assert 或 abort() 触发）";
    case SIGSEGV:  return "SIGSEGV（段错误，内存越界/空指针访问）";
    case SIGILL:   return "SIGILL（非法指令）";
    case SIGFPE:   return "SIGFPE（浮点运算错误）";
    case SIGINT:   return "SIGINT（中断信号，Ctrl+C 触发）";
    case SIGTERM:  return "SIGTERM（终止信号）";
    default:       return QString("未知信号（编号：%1）").arg(signal);
    }
}

// ==================== 工具函数：生成Dump文件（独立提取，方便复用）====================
void generateCrashDump(EXCEPTION_POINTERS* pExceptionPointers = nullptr)
{
    // 1. 创建Dump保存目录
    QDir dumpDir(QCoreApplication::applicationDirPath() + "/" + DUMP_SAVE_DIR);
    if (!dumpDir.exists() && !dumpDir.mkpath(".")) {
        MessageBoxA(nullptr, "创建Dump目录失败！", "崩溃错误", MB_ICONERROR);
        return;
    }

    // 2. 清理旧Dump文件
    QFileInfoList fileList = dumpDir.entryInfoList(
        QStringList() << "Crash_*.dmp",
        QDir::Files,
        QDir::Time | QDir::Reversed
        );
    if (fileList.size() > MAX_DUMP_COUNT) {
        for (int i = MAX_DUMP_COUNT; i < fileList.size(); ++i) {
            QFile::remove(fileList[i].filePath());
        }
    }

    // 3. 生成Dump文件名
    QString dumpFileName = dumpDir.filePath(
        QString("Crash_%1_PID%2.dmp")
            .arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss_zzz"))
            .arg(GetCurrentProcessId())
        );

    // 4. 创建并写入Dump文件
    HANDLE hDumpFile = CreateFileA(
        dumpFileName.toLocal8Bit().constData(),
        GENERIC_WRITE,
        0,
        nullptr,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
        );

    if (hDumpFile != INVALID_HANDLE_VALUE) {
        MINIDUMP_EXCEPTION_INFORMATION dumpInfo = {0};
        if (pExceptionPointers) {
            dumpInfo.ExceptionPointers = pExceptionPointers;
            dumpInfo.ThreadId = GetCurrentThreadId();
            dumpInfo.ClientPointers = TRUE;
        }

        // 生成Dump（支持带异常信息或无异常信息的主动调用）
        MiniDumpWriteDump(
            GetCurrentProcess(),
            GetCurrentProcessId(),
            hDumpFile,
            DUMP_TYPE,
            pExceptionPointers ? &dumpInfo : nullptr,
            nullptr,
            nullptr
            );

        CloseHandle(hDumpFile);
        QString tipMsg = QString("程序崩溃！\nDump文件已保存至：\n%1").arg(dumpFileName);
        MessageBoxW(nullptr, tipMsg.toStdWString().c_str(), L"崩溃提示", MB_ICONERROR | MB_OK);
    } else {
        MessageBoxA(nullptr, "创建Dump文件失败！", "崩溃错误", MB_ICONERROR);
    }
}

// ==================== 系统级崩溃处理（捕获系统异常）====================
LONG WINAPI SystemCrashHandler(EXCEPTION_POINTERS* pExceptionPointers)
{
    generateCrashDump(pExceptionPointers); // 直接调用Dump生成函数
    return EXCEPTION_EXECUTE_HANDLER;
}

// ==================== 信号处理器（捕获SIGABRT、SIGSEGV等信号）====================
void signalHandler(int signal)
{
    // 修复：用自定义函数替换 strsignal，获取Windows兼容的信号描述
    QString signalDesc = getSignalDescription(signal);
    qCritical() << "捕获到崩溃信号：" << signal << " - " << signalDesc;

    // 方式1：将信号转换为系统异常（让SystemCrashHandler捕获，推荐）
    RaiseException(
        0xE0000001, // 自定义异常代码（可任意非系统占用值）
        EXCEPTION_NONCONTINUABLE,
        0,
        nullptr
        );

    // 方式2：若方式1失败，直接生成Dump（兜底）
    generateCrashDump();

    // 终止进程（避免无限循环）
    ExitProcess(EXIT_FAILURE);
}

// ==================== Qt框架级崩溃处理（捕获Qt致命错误）====================
void QtFatalErrorHandler(QtMsgType msgType, const QMessageLogContext& context, const QString& msg)
{
    // 1. 格式化错误信息并写入日志
    QString errorDetails;
    switch (msgType) {
    // case QtDebugMsg: errorDetails = "[DEBUG] "; break;
    // case QtInfoMsg:  errorDetails = "[INFO] ";  break;
    // case QtWarningMsg: errorDetails = "[WARNING] "; break;

    case QtFatalMsg:   errorDetails = "[FATAL] ";   break;
    case QtCriticalMsg: errorDetails = "[CRITICAL] "; break;
    default: return; // 非致命错误不处理
    }
    errorDetails += QString("%1\n文件：%2\n行号：%3\n函数：%4")
                        .arg(msg)
                        .arg(context.file ? context.file : "未知")
                        .arg(context.line)
                        .arg(context.function ? context.function : "未知");

    qCritical().noquote() << "Qt致命错误：" << errorDetails;

    // 写入日志文件
    QDir logDir(QCoreApplication::applicationDirPath() + "/QtCrashLogs");
    if (!logDir.exists()) logDir.mkpath(".");
    QString logFileName = logDir.filePath(
        QString("CrashLog_%1.txt")
            .arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss"))
        );
    QFile logFile(logFileName);
    if (logFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&logFile);
        out << "崩溃时间：" << QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz") << "\n";
        out << errorDetails << "\n";
        logFile.close();
    }

    // 触发信号处理逻辑，最终生成Dump
    signalHandler(SIGABRT);
}

// ==================== 主函数（程序入口）====================
int main(int argc, char *argv[])
{
    // 注意：先初始化QApplication，再注册崩溃回调（确保Qt环境可用）
    QApplication a(argc, argv);

    // 1. 注册系统级崩溃处理（捕获空指针、内存越界等系统异常）
    SetUnhandledExceptionFilter(SystemCrashHandler);

    // 2. 注册Qt框架级崩溃处理（捕获Qt致命错误、断言失败等）
    qInstallMessageHandler(QtFatalErrorHandler);

    // ==================== 你的程序逻辑 ====================
    // 示例：故意触发崩溃（测试用，实际使用时删除）
    // QPushButton* btn = nullptr;
    // btn->click(); // 空指针崩溃（系统级，触发SystemCrashHandler）
    // qFatal("测试Qt致命错误崩溃"); // Qt框架级，触发QtFatalErrorHandler

    // 替换为你的主窗口
    // MainWindow w;
    // w.show();

    return a.exec();
}

```

### 二、项目配置（二选一：qmake 或 CMake）
1. qmake 项目（.pro 文件）

````
QT += core gui widgets
TARGET = QtCrashDumpDemo
TEMPLATE = app
CONFIG += c++17

# ==================== 仅Debug版本启用CrashDump（避免Release冗余）====================
CONFIG(debug, debug|release) {
    # 链接DbgHelp库（Windows生成Dump必需）
    LIBS += -lDbgHelp
    # 定义宏，用于条件编译（可选）
    DEFINES += ENABLE_CRASH_DUMP
    # 启用异步异常处理（捕获所有类型崩溃，必须添加）
    QMAKE_CXXFLAGS += /EHa
}

# ==================== 源文件配置 ====================
SOURCES += \
    main.cpp \
    mainwindow.cpp  # 替换为你的源文件

HEADERS += \
    mainwindow.h    # 替换为你的头文件

FORMS += \
    mainwindow.ui   # 替换为你的UI文件

# ==================== 输出目录配置（可选，规范文件结构）====================
DESTDIR = ./bin/$$BUILD_TYPE  # 输出到 bin/Debug 或 bin/Release
OBJECTS_DIR = ./build/$$BUILD_TYPE/obj
MOC_DIR = ./build/$$BUILD_TYPE/moc
RCC_DIR = ./build/$$BUILD_TYPE/rcc
UI_DIR = ./build/$$BUILD_TYPE/ui

````

2. CMake 项目（CMakeLists.txt）

````
cmake_minimum_required(VERSION 3.16)
project(QtCrashDumpDemo LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ==================== Qt配置 ====================
find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets)
qt_standard_project_setup()

# ==================== 源文件配置 ====================
set(SOURCES
    main.cpp
    mainwindow.cpp  # 替换为你的源文件
)

set(HEADERS
    mainwindow.h    # 替换为你的头文件
)

set(FORMS
    mainwindow.ui   # 替换为你的UI文件
)

# 生成可执行文件
qt_add_executable(QtCrashDumpDemo
    ${SOURCES}
    ${HEADERS}
    ${FORMS}
)

# 链接Qt库
target_link_libraries(QtCrashDumpDemo PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
)

# ==================== Debug版本专用配置（生成Dump必需）====================
if (WIN32 AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    # 链接DbgHelp库
    target_link_libraries(QtCrashDumpDemo PRIVATE DbgHelp)
    # 定义宏
    target_compile_definitions(QtCrashDumpDemo PRIVATE ENABLE_CRASH_DUMP)
    # 启用异步异常处理（捕获所有崩溃类型）
    target_compile_options(QtCrashDumpDemo PRIVATE /EHa)
endif()

# ==================== 输出目录配置（可选）====================
set_target_properties(QtCrashDumpDemo PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY_DEBUG "${CMAKE_BINARY_DIR}/bin/Debug"
    RUNTIME_OUTPUT_DIRECTORY_RELEASE "${CMAKE_BINARY_DIR}/bin/Release"
)

````


### 三、核心功能说明
双重崩溃捕获：
系统级：捕获 空指针访问、内存越界、数组溢出、线程崩溃 等系统异常（通过 SetUnhandledExceptionFilter）。
Qt 级：捕获 qFatal()、Qt断言失败、信号槽连接错误 等 Qt 框架致命错误（通过 qInstallMessageHandler）。
实用特性：
自动创建 Dump 保存目录（程序目录/QtCrashDumps）和日志目录（程序目录/QtCrashLogs）。
自动清理旧 Dump 文件（保留最新 10 个，可通过 MAX_DUMP_COUNT 调整）。
Dump 文件名包含 时间戳+进程ID，避免重复。
崩溃时弹出提示框，告知用户 Dump 文件路径。
生成 Qt 错误日志文件（包含崩溃时间、文件、行号），辅助排查。
Dump 文件完整性：
使用 MiniDumpWithFullMemory | MiniDumpWithHandleData | MiniDumpWithThreadInfo 生成完整转储，包含：
进程所有内存数据（变量、堆、栈）。
句柄信息（文件、线程、互斥锁等）。
线程信息（所有线程的调用栈）。
调试时能精准定位崩溃行、查看变量值和调用栈。
四、测试方法（验证是否生效）
在 main 函数中取消注释以下测试代码，编译运行后会触发崩溃，验证 Dump 文件是否生成：

````c++
// 测试1：系统级崩溃（空指针访问）
QPushButton* btn = nullptr;
btn->click();

// 测试2：Qt框架级崩溃（qFatal致命错误）
// qFatal("测试Qt框架崩溃");
````

运行后会：
弹出崩溃提示框，显示 Dump 文件路径。
在 程序目录/QtCrashDumps 下生成 .dmp 文件。
在 程序目录/QtCrashLogs 下生成错误日志（仅 Qt 级崩溃有）。


## 五、调试 Dump 文件（关键步骤）

保留 PDB 文件：Debug 版本编译后，bin/Debug 目录会生成 QtCrashDumpDemo.exe 和 QtCrashDumpDemo.pdb（符号文件），切勿删除，调试 Dump 必须依赖。
使用 Visual Studio 调试：
打开 Visual Studio → 文件 → 打开 → 文件 → 选择生成的 .dmp 文件。
点击「调试转储」窗口的「设置符号路径」→ 添加 bin/Debug 目录（包含 .exe 和 .pdb）。
点击「开始调试」（绿色箭头），Visual Studio 会自动定位到崩溃代码行、调用栈和变量值。


## 六、注意事项

仅 Debug 版本生效：Release 版本会优化代码（变量消除、内联函数），即使生成 Dump，也无法精准定位原始代码，务必用 Debug 版本测试。
Qt 编译架构匹配：程序是 x86 还是 x64，需与调试工具（Visual Studio/WinDbg）架构一致（例如 x64 程序用 x64 版本调试工具）。
Dump 文件大小：完整转储（MiniDumpWithFullMemory）文件较大（可能几 GB），若需减小体积，可改为 MiniDumpNormal（仅核心信息，几十 MB），但调试信息会减少。
管理员权限：若程序需要管理员权限运行，崩溃时生成 Dump 也需要管理员权限，建议以管理员身份启动程序（避免创建 Dump 目录失败）。
此实现已覆盖绝大多数崩溃场景，直接集成到你的 Qt 项目中即可使用，无需额外依赖，调试时能快速定位问题根源。